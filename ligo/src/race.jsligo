#import "types.jsligo" "Types"

type reward = Types.reward;
type race_storage = Types.race_storage;
type tezrun_storage = Types.tezrun_storage;
type return_type = [list<operation>, tezrun_storage]

export type race_param = 
    ["Set_ready_time", int]
  | ["Ready_race"]
  | ["Start_race"]
  | ["Finish_race", nat];

const empty_operation_list = (list([]) as list<operation>);

const set_ready_time = ([ready_time, race] : [int, race_storage]) : race_storage => {
  if (ready_time <= 0) {
    return failwith("INVALID_TIME");
  } else {
    return {
      ...race,
      ready_time: ready_time,
    };
  }
};

const ready_race = (race : race_storage) : race_storage => {
  const ready_time = race.ready_time;
  return {
    ...race,
    status: 1 as nat,
    start_time: Tezos.get_now() + ready_time,
  };
};

const start_race = (race : race_storage) : race_storage => {
  const new_race_id = (1 as nat) + race.race_id;
  return {
    ...race,
    race_id: new_race_id,
    status: 2 as nat,
    start_time: Tezos.get_now(),
    winner: 0 as nat,
    bets: list([]) as Types.ticket_list,
  };
};

const finish_race = ([winner, storage] : [nat, tezrun_storage]) : return_type => {
  const race = storage.race;
  if (race.status != (2 as nat)) {
    return failwith("RACE_NOT_STARTED");
  } else {
    let new_rewards = race.rewards;
    for (const ticket of race.bets) {
      if (ticket.horse_id == winner) {

        if (ticket.token == 0) {
          // Calculate the tezos amount that can be rewarded
          const amount = ticket.tezos * ticket.payout;

          // Check if reward already exists in reward map
          const has_balance = Big_map.mem(ticket.address, new_rewards);
          if (has_balance) {
            const reward_opt: option<reward> = Big_map.find_opt(ticket.address, new_rewards);
            const reward: reward = Option.unopt(reward_opt);
            const new_reward = {
              ...reward,
              tezos: reward.tezos + amount
            };
            new_rewards = Big_map.update(ticket.address, Some(new_reward), new_rewards);
          } else {
            const reward: reward = {
              tezos: amount,
              tokens: Map.empty as Types.token_map
            };
            new_rewards = Big_map.add(ticket.address, reward, new_rewards);
          }
        }
      }
    };
    const ready_time = race.ready_time;
    const new_race: race_storage = {
      ...race,
      status: 1 as nat,
      winner: winner,
      rewards: new_rewards,
      start_time: Tezos.get_now() + ready_time,
    };
    const new_s: tezrun_storage = {
      ...storage,
      race: new_race,
    };
    return [empty_operation_list, new_s];
  }
};

export const main = ([param, storage] : [race_param, tezrun_storage]) : return_type => {
  match(param, {
    Set_ready_time: (ready_time: int) => {
      const race = set_ready_time(ready_time, storage.race);
      const new_s : tezrun_storage = {
        ...storage,
        race,
      };
      return [empty_operation_list, new_s];
    },
    Ready_race: () => {
      const race = ready_race(storage.race);
      const new_s : tezrun_storage = {
        ...storage,
        race,
      };
      return [empty_operation_list, new_s];
    },
    Start_race: () => {
      const race = start_race(storage.race);
      const new_s : tezrun_storage = {
        ...storage,
        race,
      };
      return [empty_operation_list, new_s];
    },
    Finish_race: (winner: nat) => {
      return finish_race(winner, storage);
    }
  })
};