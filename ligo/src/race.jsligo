#import "types.jsligo" "Types"

type reward = Types.reward;
type token_map = Types.token_map;
type tezrun_storage = Types.tezrun_storage;
type return_type = [list<operation>, tezrun_storage];

export type race_param = 
    ["Set_ready_time", int]
  | ["Ready_race"]
  | ["Start_race"]
  | ["Finish_race", nat];

const empty_operation_list = (list([]) as list<operation>);

const set_ready_time = ([ready_time, storage] : [int, tezrun_storage]) : tezrun_storage => {
  if (ready_time <= 0) {
    return failwith("INVALID_TIME");
  } else {
    return {
      ...storage,
      ready_time: ready_time,
    };
  }
};

const ready_race = (storage : tezrun_storage) : tezrun_storage => {
  const ready_time = storage.ready_time;
  return {
    ...storage,
    status: 1 as nat,
    start_time: Tezos.get_now() + ready_time,
  };
};

const start_race = (storage : tezrun_storage) : tezrun_storage => {
  const new_race_id = (1 as nat) + storage.race_id;
  return {
    ...storage,
    race_id: new_race_id,
    status: 2 as nat,
    start_time: Tezos.get_now(),
    winner: 0 as nat,
    tickets: list([]) as Types.ticket_list,
  };
};

const update_reward_tokens = ([tokens, token_id, amount] : [token_map, int, nat]) : token_map => {
  return match(Map.find_opt(token_id, tokens), {
    Some: old_amount => {
      return Map.update(token_id, Some(old_amount + amount), tokens);
    },
    None: () => {
      return Map.add(token_id, amount, tokens);
    },
  });
};

const finish_race = ([winner, storage] : [nat, tezrun_storage]) : return_type => {
  if (storage.status != (2 as nat)) {
    return failwith("RACE_NOT_STARTED");
  } else {
    let new_rewards = storage.rewards;
    for (const ticket of storage.tickets) {
      if (ticket.horse_id == winner) {
        if (ticket.token == 0) {
          // Calculate the tezos amount that can be rewarded
          const amount = ticket.tezos * ticket.payout;

          // Update tezos amount in the rewards list
          new_rewards = match(Big_map.find_opt(ticket.address, new_rewards), {
            Some: reward => {
              const new_reward = {
                ...reward,
                tezos: reward.tezos + amount
              };
              return Big_map.update(ticket.address, Some(new_reward), new_rewards);
            },
            None: () => {
              const reward: reward = {
                tezos: amount,
                tokens: Map.empty as Types.token_map
              };
              return Big_map.add(ticket.address, reward, new_rewards);
            },
          });
        }
        else if (ticket.token == 1) {
          // Calculate the token amount that can be rewarded
          const amount = ticket.amount * ticket.payout;

          // Update token amount in the rewards list
          new_rewards = match(Big_map.find_opt(ticket.address, new_rewards), {
            Some: reward => {
              const tokens = update_reward_tokens(reward.tokens, 1, amount);
              const new_reward = {
                ...reward,
                tokens,
              }
              return Big_map.update(ticket.address, Some(new_reward), new_rewards);
            },
            None: () => {
              const new_reward: reward = {
                tezos: 0 as tez,
                tokens: Map.literal(list([
                  [1, amount]
                ])),
              };
              return Big_map.add(ticket.address, new_reward, new_rewards);
            },
          });
        }
      }
    };
    const ready_time = storage.ready_time;
    const new_s: tezrun_storage = {
      ...storage,
      status: 1 as nat,
      winner: winner,
      rewards: new_rewards,
      start_time: Tezos.get_now() + ready_time,
    };
    return [empty_operation_list, new_s];
  }
};

export const main = ([param, storage] : [race_param, tezrun_storage]) : return_type => {
  match(param, {
    Set_ready_time: (ready_time: int) => {
      const new_s = set_ready_time(ready_time, storage);
      return [empty_operation_list, new_s];
    },
    Ready_race: () => {
      const new_s = ready_race(storage);
      return [empty_operation_list, new_s];
    },
    Start_race: () => {
      const new_s = start_race(storage);
      return [empty_operation_list, new_s];
    },
    Finish_race: (winner: nat) => {
      return finish_race(winner, storage);
    }
  })
};