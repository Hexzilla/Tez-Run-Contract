#import "types.jsligo" "Types"

type race_storage = Types.race_storage;

type return_type = [list<operation>, race_storage]

export type race_param = 
    ["Set_ready_time", int]
  | ["Ready_race"]
  | ["Start_race"]
  | ["Finish_race", nat];


const set_ready_time = ([ready_time, storage] : [int, race_storage]) : race_storage => {
  if (ready_time <= 0) {
    return failwith("INVALID_TIME");
  } else {
    return {
      ...storage,
      ready_time: ready_time,
    };
  }
};

const ready_race = (storage : race_storage) : race_storage => {
  const ready_time = storage.ready_time;
  return {
    ...storage,
    status: 1 as nat,
    start_time: Tezos.get_now() + ready_time,
  };
};

const start_race = (storage : race_storage) : race_storage => {
  const new_race_id = (1 as nat) + storage.race_id;
  return {
    ...storage,
    race_id: new_race_id,
    status: 2 as nat,
    start_time: Tezos.get_now(),
    winner: 0 as nat,
    bets: list([]) as Types.bet_list,
  };
};

const finish_race = ([winner, storage] : [nat, race_storage]) : race_storage => {
  if (storage.status != (2 as nat)) {
    return failwith("RACE_NOT_STARTED");
  } else {
    let new_rewards = storage.rewards;
    for (const bet of storage.bets) {
      if (bet.horse_id == winner) {
        const reward = bet.amount * bet.payout;
        const has_balance = Big_map.mem(bet.address, new_rewards);
        if (has_balance) {
          const balance_opt: option<tez> = Big_map.find_opt(bet.address, new_rewards);
          const balance = Option.unopt(balance_opt);
          new_rewards = Big_map.update(bet.address, Some(balance + reward), new_rewards);
        } else {
          new_rewards = Big_map.add(bet.address, reward, new_rewards);
        }
      }
    };
    const ready_time = storage.ready_time;
    return {
      ...storage,
      status: 1 as nat,
      winner: winner,
      rewards: new_rewards,
      start_time: Tezos.get_now() + ready_time,
    };
  }
};

export const main = ([param, storage] : [race_param, race_storage]) : return_type => {
  match(param, {
    Set_ready_time: (ready_time: int) => {
      const new_s = set_ready_time(ready_time, storage);
      return [(list([]) as list<operation>), new_s];
    },
    Ready_race: () => {
      const new_s = ready_race(storage);
      return [(list([]) as list<operation>), new_s];
    },
    Start_race: () => {
      const new_s = start_race(storage);
      return [(list([]) as list<operation>), new_s];
    },
    Finish_race: (winner: nat) => {
      const new_s = finish_race(winner, storage);
      return [(list([]) as list<operation>), new_s];
    }
  })
};