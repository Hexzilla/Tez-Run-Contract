#import "types.jsligo" "Types"

type bet = Types.bet;
type bet_list = Types.bet_list; 
type reward_ledger = Types.reward_ledger;
type race_storage = Types.race_storage;

type return_type = [list<operation>, race_storage];

type place_bet_param = {
  race_id : nat,
  horse_id : nat,
  payout : nat,
};

export type betting_param = 
    ["Place_bet", place_bet_param]
  | ["Take_reward"];


const place_bet = ([param, storage] : [place_bet_param, race_storage]) : race_storage => {
  const betting: bet = {
    address: Tezos.get_sender(),
    race_id: param.race_id,
    horse_id: param.horse_id,
    payout: param.payout,
    amount: Tezos.get_amount(),
  };
  const new_bets: bet_list = list([betting, ...storage.bets]);
  return {
    ...storage,
    bets: new_bets,
  };
};

const take_reward = (storage: race_storage) : race_storage => {
  let address = Tezos.get_sender();
  let rewards = storage.rewards;
  let has_balance = Big_map.mem(address, rewards);
  if (has_balance) {
    const balance_opt: option<tez> = Big_map.find_opt(address, rewards);
    const balance = Option.unopt(balance_opt);

    if (balance > (0 as tez)) {
      rewards = Big_map.update(address, Some(0 as tez), rewards);
    }
  }

  return {
    ...storage,
    rewards: rewards,
  }
}

export const main = ([param, storage] : [betting_param, race_storage]) : return_type => {
  match(param, {
    Place_bet: (p: place_bet_param) => {
      const new_s = place_bet(p, storage);
      return [(list([]) as list<operation>), new_s];
    },
    Take_reward: () => {
      const new_s = take_reward(storage);
      return [(list([]) as list<operation>), new_s];
    }
  })
};